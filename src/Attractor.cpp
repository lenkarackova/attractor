#include "include/Attractor.h"
#include "include/Vertex.h"

#include "include/helpers.h"

#include <QMetaEnum>
#include <QFile>
#include <limits>

Attractor::Attractor(AttractorType type, ColorModel* colorModel)
    : m_colorModel(colorModel)
{
    m_parameterModel = new ParameterModel();
    QObject::connect(m_parameterModel, &QAbstractListModel::dataChanged,
                     this, &Attractor::onParametersChanged);

    setType(type);
}

Attractor::Attractor(AttractorType type, std::vector<float> parameters, ColorModel* colorModel)
    : Attractor(type, colorModel)
{
    setParameters(parameters);
}

void Attractor::exportOBJ(QString filename, int count)
{
    QFile file(QUrl(filename).toLocalFile());
    if(file.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        QTextStream out(&file);

        out << "# This file is generated by AttractorExplorer V2\n" << Qt::endl;
        out << "# Attractor type: " << QMetaEnum::fromType<AttractorType>().key(type()) << Qt::endl;

        out << "# Center: " << center().x() << ", " << center().y() << ", " << center().z() << Qt::endl;
        out << "# Scale: " << scale().x() << ", " << scale().y() << ", " << scale().z() << Qt::endl;
        out << "# Min: " << min().x() << ", " << min().y() << ", " << min().z() << Qt::endl;
        out << "# Max: " << max().x() << ", " << max().y() << ", " << max().z() << Qt::endl;

        out << "# Parameters: ";
        for(int i = 0; i < m_parameterModel->rowCount(); ++i)
        {
            out << m_parameterModel->index(i).data(ParameterModel::ValueRole).toString();
            if (i < m_parameterModel->rowCount() - 1)
                out << ", ";
        }
        out << Qt::endl << Qt::endl;

        getPoints(count, [&](QVector3D const& v, QColor const& c) {
            out << "v " << v.x() << " " << v.y() << " " << v.z() << Qt::endl;
        });

        file.close();
    }
}


QStringList Attractor::attractorTypes()
{
    QMetaEnum metaEnum = QMetaEnum::fromType<AttractorType>();
    QStringList enumStrings;

    for(int i = 0; i < metaEnum.keyCount(); ++i)
    {
        enumStrings.append(metaEnum.key(i));
    }

    return enumStrings;
}

QAbstractListModel *Attractor::parameterModel()
{
    //return m_system->parameterModel();
    return m_parameterModel;
}


QVector3D Attractor::min() const
{
    return m_data.min.toVector3D();
}


QVector3D Attractor::max() const
{
    return m_data.max.toVector3D();
}

QVector3D Attractor::center() const
{
    return m_data.center.toVector3D();
}

QVector3D Attractor::scale() const
{
    return m_data.scale;
}


// initialize with or without lyaunov / point attractor clasification
void Attractor::initialize(bool tests)
{
    //set initial coordinates
    Vertex v0(0.001);	// current coodrinate, set near zero
    Vertex v1(0.0);		// previous coordinate
    Vertex v2(0.0);		// second to last coordinate

    // set epsilons near x,y,z for computing lyapunov
    Vertex e1(0.0);		// previous epsilon
    Vertex e0			// current epsilon
    (
        v0.x() + random_double(-1.0, 1.0) / 100.0,
        v0.y() + random_double(-1.0, 1.0) / 100.0,
        v0.z() + random_double(-1.0, 1.0) / 100.0
    );

    // set deltas
    Vertex d(v0.x() - e0.x(), v0.y() - e0.y(), v0.z() - e0.z());
    const float d0 = sqrt(d.x()*d.x() + d.y()*d.y() + d.z()*d.z());
    float dd;

    Vertex min, max;	// minimal / maximal coordinate

    // further initializations...
    m_data.center = m_data.max = m_data.min = Vertex(0.0);
    double speed = m_data.maxSpeed = 0.0; //distance between two succesive points
    double angle = m_data.maxAngle = 0.0; //angle between three succesive points

    m_data.minAngle = 3.141592;
    m_data.lyapunov = 0.0;
    m_data.drawable = true;
    m_data.chaotic  = true;

    int i = 0;
    for (; i < INITIALIZE_ITERATIONS; i++)
    {
        v2 = v1;
        v1 = v0;
        e1 = e0;

        m_system->next(v0);
        m_system->next(e0);

        // infinite attractor
        if (v0.isInfinite())
        {
            m_data.infinite++;
            m_data.drawable = false;
            m_data.chaotic = false;
            break;
        }

        if (tests)
        {
            // point attractor
            if (fabs(v0.x() - v1.x()) < 1e-10 &&
                fabs(v0.y() - v1.y()) < 1e-10 &&
                fabs(v0.z() - v1.z()) < 1e-10)
            {
                m_data.point++;
                m_data.drawable = true;
                m_data.chaotic = false;
                break;
            }

            if (i > SETTLE_ITERATIONS)
            {
                // calculate lyapunov
                d.delta(v0, e0);
                dd = sqrt(d.x()*d.x() + d.y()*d.y() + d.z()*d.z());

                if (dd > 0 && dd <= std::numeric_limits<double>::max() && d0 != 0)
                {
                    m_data.lyapunov += log(fabs(dd/d0));
                    e0 = Vertex(v0.x() + d0 * d.x() / dd, v0.y() + d0 * d.y() / dd, v0.z() + d0 * d.z() / dd);
                }
                else
                {
                    break;
                }
            }
        }

        // initialize bounds
        if (i == SETTLE_ITERATIONS)
        {
            max = min = v0;
        }

        if (i > SETTLE_ITERATIONS)
        {
            speed = v1.distanceToPoint(v0);
            angle = v1.angle(v2, v0);

            // update bounds
            max.updateMax(v0);
            min.updateMin(v0);

            if (speed > m_data.maxSpeed) m_data.maxSpeed = speed;
            if (angle > m_data.maxAngle) m_data.maxAngle = angle;
            if (angle < m_data.minAngle) m_data.minAngle = angle;
        }
    }

    // lyapunov classification
    if (tests)
    {
        m_data.lyapunov /= i;

        // neutrally stable attractor
        if (fabs(m_data.lyapunov) < 1e-2)
        {
            m_data.stable++;
            m_data.drawable = true;
            m_data.chaotic = false;
        }

        // periodic attractor
        else if (m_data.lyapunov < 0.0)
        {
            m_data.periodic++;
            m_data.drawable = true;
            m_data.chaotic = false;
        }

        // else -> chaotic attractor
        else
        {
            m_data.drawable = true;
            m_data.chaotic = true;
        }
    }

    // save min/max coordinates, compute scale
    if (m_data.drawable)
    {
        m_data.max = max;
        m_data.min = min;
        m_data.center = Vertex((max.x() + min.x()) / 2, (max.y() + min.y()) / 2, (max.z() + min.z()) / 2);

        // compute scale to fit 100 x 100 rectangle
        const float margin = 1.0f;
        const float width = 100.0f;
        const float height = 100.0f;

        float a_width = fabs(max.x() - min.x());
        float a_height = fabs(max.y() - min.y());

        if (a_width && a_height)
        {
            const float xscale = (width - 2.0 * margin) / a_width;
            const float yscale = (height - 2.0 * margin) / a_height;
            float scale = xscale > yscale ? yscale : xscale;
            m_data.scale = QVector3D(scale, scale, scale);
        }
        else
        {
            m_data.scale = QVector3D(1, 1, 1);
        }

        //emit attractorChanged();
        //emit centerChanged();
        //emit scaleChanged();
    }
}


bool Attractor::random()
{
    srand(static_cast<unsigned>(time(NULL)));
    m_data.randoms = m_data.point = m_data.infinite = m_data.stable = m_data.periodic = 0;

    std::vector<float> rand;

    for (int i = 0; i < RANDOM_TRIES; i++)
    {
        rand.clear();

        // fill parameter array with random values from appropriate range
        for (int i = 0; i < m_parameterModel->parameterCount(); ++i)
        {
            rand.push_back(random_double(m_parameterModel->min(i), m_parameterModel->max(i)));
        }

        m_parameterModel->setParameterValues(rand, false);

        //m_system->random();
        initialize(true);
        if (m_data.chaotic) break;
    }

    // random attractor not found after RANDOM_TRIES iterations
    if (!m_data.chaotic)
    {
        m_system->reset();
        return false;
    }
    else
    {
        m_parameterModel->setParameterValues(rand);
        //emit attractorChanged();
        //emit centerChanged();
        //emit scaleChanged();
        return true;
    }
}


Attractor::AttractorType Attractor::type() const
{
    return m_type;
}


void Attractor::setType(AttractorType type)
{
    if (type == m_type)
        return;

    m_type = type;

    switch (m_type)
    {
    case AttractorType::Lorenz84:
        m_system = new Lorenz84Attractor(m_parameterModel);
        break;
    case AttractorType::Rossler:
        m_system = new RosslerAttractor(m_parameterModel);
        break;
    case AttractorType::Pickover:
        m_system = new PickoverAttractor(m_parameterModel);
        break;
    case AttractorType::Clifford:
        m_system = new CliffordAttractor(m_parameterModel);
        break;
    case AttractorType::CliffordRectangle:
        m_system = new CliffordRectangleAttractor(m_parameterModel);
        break;
    case AttractorType::DeJong:
        m_system = new DeJongAttractor(m_parameterModel);
        break;
    case AttractorType::DeJong2:
        m_system = new DeJong2Attractor(m_parameterModel);
        break;
    case AttractorType::PolynomialA:
        m_system = new PolynomialAAttractor(m_parameterModel);
        break;
    case AttractorType::PolynomialB:
        m_system = new PolynomialBAttractor(m_parameterModel);
        break;
    case AttractorType::PolynomialC:
        m_system = new PolynomialCAttractor(m_parameterModel);
        break;
    case AttractorType::PolynomialAbs:
        m_system = new PolynomialAbsAttractor(m_parameterModel);
        break;
    case AttractorType::PolynomialPower:
        m_system = new PolynomialPowerAttractor(m_parameterModel);
        break;
    case AttractorType::RabinovichFabrikant:
        m_system = new RabinovichFabrikantAttractor(m_parameterModel);
        break;
    case AttractorType::Lorenz:
    default:
        m_system = new LorenzAttractor(m_parameterModel);
    }

    initialize(false);
    //emit typeChanged(m_type);
    //emit centerChanged();
    //emit scaleChanged();
    emit attractorChanged();
}


void Attractor::setParameters(std::vector<float> parameters)
{
    //m_system->setParameters(parameters);
    if (m_parameterModel->setParameterValues(parameters))
    {
        initialize(false);
        //emit parametersChanged();
    }
}


void Attractor::setColorModel(ColorModel *colorModel)
{
    m_colorModel = colorModel;
}

void Attractor::onParametersChanged()
{
    emit attractorChanged();
}

